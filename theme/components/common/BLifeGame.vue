<script setup lang="ts">
import type { ThemeConfig } from "../../types";
import { useData } from "vitepress";
// Generated by AI
import { computed, onMounted, ref, watch } from "vue";
import BButton from "./BButton.vue";
import BPopover from "./BPopover.vue";

// Props 定义和默认值
const {
  rows = 10,
  cols = 10,
  cellSize = 30,
  speed = 2,
  cellColor = "#000",
  borderColor = "#ccc",
  initialSeed,
} = defineProps<Props>();

const { theme } = useData<ThemeConfig>();
const lifeGame = computed(() => theme.value.notFound?.lifeGame);

// 类型定义
interface Props {
  rows?: number;
  cols?: number;
  initialSeed?: boolean[][];
  cellSize?: number;
  speed?: number;
  cellColor?: string;
  borderColor?: string;
}

// DOM 引用
const canvasRef = ref<HTMLCanvasElement | null>(null);

// 状态管理
const grid = ref<boolean[][]>([]);
const isPlaying = ref(true);
let animationId: number;
let lastTime = 0;

// 历史记录状态
const historyStates = ref<boolean[][][]>([]);
const currentHistoryIndex = ref(-1);
const MAX_HISTORY = 100;

// 初始化相关函数
function initGrid() {
  const newGrid: boolean[][] = [];
  for (let i = 0; i < rows; i++) {
    newGrid[i] = [];
    for (let j = 0; j < cols; j++) {
      if (initialSeed) {
        newGrid[i][j] = initialSeed[i][j];
      } else {
        newGrid[i][j] = Math.random() > 0.7;
      }
    }
  }
  grid.value = newGrid;
  // 重置历史记录
  historyStates.value = [JSON.parse(JSON.stringify(newGrid))];
  currentHistoryIndex.value = 0;
}

// 渲染相关函数
function draw() {
  if (!canvasRef.value) {
    return;
  }
  const ctx = canvasRef.value.getContext("2d");
  if (!ctx) {
    return;
  }

  ctx.clearRect(0, 0, canvasRef.value.width, canvasRef.value.height);

  // 绘制格子
  for (let i = 0; i < rows; i++) {
    for (let j = 0; j < cols; j++) {
      // 绘制边界
      ctx.strokeStyle = borderColor;
      ctx.strokeRect(
        j * cellSize,
        i * cellSize,
        cellSize,
        cellSize,
      );

      // 绘制活细胞
      if (grid.value[i][j]) {
        ctx.fillStyle = cellColor;
        ctx.fillRect(
          j * cellSize + 1, // +1 避免覆盖边界
          i * cellSize + 1, // +1 避免覆盖边界
          cellSize - 2, // -2 避免覆盖边界
          cellSize - 2, // -2 避免覆盖边界
        );
      }
    }
  }
}

// 游戏逻辑相关函数
function nextGeneration() {
  const newGrid = grid.value.map(arr => [...arr]);

  for (let i = 0; i < rows; i++) {
    for (let j = 0; j < cols; j++) {
      const neighbors = countNeighbors(i, j);
      if (grid.value[i][j]) {
        newGrid[i][j] = neighbors === 2 || neighbors === 3;
      } else {
        newGrid[i][j] = neighbors === 3;
      }
    }
  }

  grid.value = newGrid;

  // 添加到历史记录
  if (currentHistoryIndex.value < historyStates.value.length - 1) {
    // 如果不是在最新状态，删除当前位置之后的历史
    historyStates.value = historyStates.value.slice(0, currentHistoryIndex.value + 1);
  }

  // 添加新状态到历史
  historyStates.value.push(JSON.parse(JSON.stringify(newGrid)));
  if (historyStates.value.length > MAX_HISTORY) {
    historyStates.value.shift(); // 删除最老的记录
  } else {
    currentHistoryIndex.value++;
  }
}

function countNeighbors(row: number, col: number) {
  let count = 0;
  for (let i = -1; i <= 1; i++) {
    for (let j = -1; j <= 1; j++) {
      if (i === 0 && j === 0) {
        continue;
      }
      const newRow = (row + i + rows) % rows;
      const newCol = (col + j + cols) % cols;
      if (grid.value[newRow][newCol]) {
        count++;
      }
    }
  }
  return count;
}

// 控制相关函数
function togglePlay() {
  isPlaying.value = !isPlaying.value;
  if (isPlaying.value) {
    startGame();
  } else {
    cancelAnimationFrame(animationId);
  }
}

function prevStep() {
  if (currentHistoryIndex.value <= 0) {
    return;
  }

  // 暂停游戏
  isPlaying.value = false;
  cancelAnimationFrame(animationId);

  // 回到上一步
  currentHistoryIndex.value--;
  grid.value = JSON.parse(JSON.stringify(historyStates.value[currentHistoryIndex.value]));
  draw();
}

function nextStep() {
  // 如果有下一步历史记录
  if (currentHistoryIndex.value < historyStates.value.length - 1) {
    isPlaying.value = false;
    cancelAnimationFrame(animationId);
    currentHistoryIndex.value++;
    grid.value = JSON.parse(JSON.stringify(historyStates.value[currentHistoryIndex.value]));
    draw();
  } else {
    // 生成新的下一步
    isPlaying.value = false;
    cancelAnimationFrame(animationId);
    nextGeneration();
    draw();
  }
}

function startGame() {
  const update = (currentTime: number) => {
    if (!isPlaying.value) {
      return;
    }

    const deltaTime = currentTime - lastTime;
    if (deltaTime > 1000 / speed) {
      // 从历史记录的当前位置继续
      nextGeneration();
      draw();
      lastTime = currentTime;
    }
    animationId = requestAnimationFrame(update);
  };

  requestAnimationFrame(update);
}

function reset() {
  isPlaying.value = false;
  cancelAnimationFrame(animationId);
  initGrid();
  draw();
}

// 生命周期钩子
onMounted(() => {
  if (canvasRef.value) {
    canvasRef.value.width = cols * cellSize;
    canvasRef.value.height = rows * cellSize;
  }
  initGrid();
  draw();
  if (isPlaying.value) {
    startGame();
  }
});

// 监听属性变化
watch([() => rows, () => cols, () => initialSeed, () => speed], () => {
  if (canvasRef.value) {
    canvasRef.value.width = cols * cellSize;
    canvasRef.value.height = rows * cellSize;
  }
  initGrid();
});
</script>

<template>
  <div class="group w-fit flex flex-col items-center gap-sm">
    <canvas ref="canvasRef"></canvas>
    <div class="flex gap-sm opacity-0 transition group-hover:opacity-100">
      <BPopover trigger="hover" :delay="500">
        <template #reference>
          <BButton variant="ghost" size="icon" :disabled="currentHistoryIndex <= 0" @click="prevStep">
            <div class="i-lucide-chevron-left"></div>
          </BButton>
        </template>
        {{ lifeGame?.prevStep || 'Previous step' }}
      </BPopover>
      <BPopover trigger="hover" :delay="500">
        <template #reference>
          <BButton variant="ghost" size="icon" @click="togglePlay">
            <div :class="[isPlaying ? 'i-lucide-pause' : 'i-lucide-play']"></div>
          </BButton>
        </template>
        {{ isPlaying ? lifeGame?.pause || 'Pause' : lifeGame?.play || 'Play' }}
      </BPopover>
      <BPopover trigger="hover" :delay="500">
        <template #reference>
          <BButton variant="ghost" size="icon" @click="nextStep">
            <div class="i-lucide-chevron-right"></div>
          </BButton>
        </template>
        {{ lifeGame?.nextStep || 'Next step' }}
      </BPopover>
      <BPopover trigger="hover" :delay="500">
        <template #reference>
          <BButton variant="ghost" size="icon" @click="reset">
            <div class="i-lucide-refresh-cw"></div>
          </BButton>
        </template>
        {{ lifeGame?.reset || 'Reset' }}
      </BPopover>
    </div>
  </div>
</template>
